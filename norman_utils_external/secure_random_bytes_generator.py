import os

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
from cryptography.hazmat.backends import default_backend
from norman_utils_external.singleton import Singleton


class SecureRandomBytesGenerator(metaclass=Singleton):
    """
    Cryptographically secure pseudo-random byte generator using ChaCha20.

    This utility produces an arbitrary number of cryptographically strong
    random bytes, suitable for:
    - Nonces
    - Encryption keys
    - Session tokens
    - Salts
    - Any security-sensitive randomness

    The generator is implemented as a singleton so that the internal
    ChaCha20 stream cipher state is preserved across calls. This avoids
    reseeding and ensures consistent forward-secure random output.

    **Implementation Details**

    - A 32-byte random key and 16-byte random nonce are generated using
      `os.urandom()`.
    - ChaCha20 is initialized in *stream mode* using the key + nonce.
    - Each call to `next()` advances the cipher stream and returns the
      corresponding encrypted zero bytes as random output.
    """

    def __init__(self):
        self.seed_key = os.urandom(32)
        self.seed_nonce = os.urandom(16)

        algorithm = algorithms.ChaCha20(self.seed_key, self.seed_nonce)
        cipher = Cipher(algorithm, mode=None, backend=default_backend())
        self._stream = cipher.encryptor()

    def next(self, number_of_bytes: int):
        """
        Generate the next `number_of_bytes` pseudo-random bytes from the
        ChaCha20 stream.

        **Parameters**

        - **number_of_bytes** (`int`)
          Number of random bytes to produce.

        **Returns**

        - **bytes** â€” A bytes object containing the requested number of
          cryptographically secure random bytes.

        **Notes**

        - Output is generated by encrypting a sequence of zero bytes.
          This is standard practice for stream-cipher-based random generators.
        - The internal stream cipher state automatically advances, so
          subsequent calls will never repeat previous output.
        - The function does *not* reseed; for a new independent generator
          instance, construct a new object (which is normally prevented by
          the `Singleton` metaclass).

        **Example**
        ```python
        rng = SecureRandomBytesGenerator()
        nonce = rng.next(12)         # generate 12 random bytes
        key   = rng.next(32)         # generate 32 random bytes
        ```
        """
        return self._stream.update(b'\x00' * number_of_bytes)
